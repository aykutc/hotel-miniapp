import React, { useState, useRef, useEffect } from "react";

const OptimizedImage = ({
  src,
  alt,
  maxWidth,
  className,
  loading,
  ...props
}) => {
  if (src.includes("base64")) {
    return (
      // eslint-disable-next-line @next/next/no-img-element
      <img
        src={src}
        loading={loading === "eager" ? "eager" : "lazy"}
        alt={alt}
        {...props}
      />
    );
  } else {
    return (
      <>
        <Image
          src={src}
          alt={alt}
          maxWidth={maxWidth}
          className={className}
          loading={loading}
          {...props}
        ></Image>
        <style jsx>{`
          .aspectRatio {
            position: relative;
            height: 0;
          }

          .picture {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
          }

          .image {
            width: 100%;
            height: 100%;
            display: block;
            opacity: 0;
            transition: opacity 200ms ease-out;
            object-fit: cover;
          }

          .image.loading {
            opacity: 0;
          }

          .image.loaded {
            opacity: 1;
          }
        `}</style>
      </>
    );
  }
};

function Image({
  src,
  alt,
  maxWidth,
  className,
  loading: loadingState,
  ...props
}) {
  const fallbackSource = require(`../../public/images/${src}`);
  const webpSource = require(`../../public/images/${src}?format=webp`);

  const [loaded, setLoaded] = useState(false);
  const [loading, setLoading] = useState(false);
  const imageRef = useRef();

  function handleImageLoaded(event) {
    if (imageRef.current) {
      const image = imageRef.current.querySelector("img");
      if (!image.complete) {
        setLoading(true);
      } else {
        setLoading(false);
        setLoaded(true);
      }
    }
  }

  useEffect(() => {
    if (imageRef.current) {
      const image = imageRef.current.querySelector("img");
      if (image.complete) {
        setLoaded(true);
      } else {
        setLoaded(false);
        setLoading(true);
      }
    }
  }, []);

  const mediaMap = [
    "(max-width: 360px)",
    "(min-width: 361px) and (max-width: 480px)",
    "(min-width: 481px) and (max-width: 600px)",
    "(min-width: 601px)",
  ];

  return (
    <>
      <div
        ref={imageRef}
        style={{
          width: "100%",
          maxWidth: maxWidth ? `${maxWidth}px` : "100%",
        }}
      >
        <picture>
          {mediaMap.map((media, index) => {
            // Get total images generated by responsive-loader
            const totalImages = fallbackSource.images.length - 1;
            // Set imageIndex to current index
            let imageIndex = index;
            // If index is greater or equal to totalImages generated,
            // use the largest to fulfill all media requirements
            if (index >= totalImages) {
              imageIndex = totalImages;
            }
            // Get fallback image path and WebP paths
            const fallbackPath = fallbackSource.images[imageIndex].path;
            const webpPath = webpSource.images[imageIndex].path;
            // Get mime type
            const findExtension = fallbackPath.match(/[^.]+$/);
            const fallbackMimeType =
              findExtension[0] === "jpg" ? "jpeg" : findExtension[0];
            return (
              <React.Fragment key={`image_${index}`}>
                <source srcSet={webpPath} media={media} type="image/webp" />
                <source
                  srcSet={fallbackPath}
                  media={media}
                  type={`image/${fallbackMimeType}`}
                />
              </React.Fragment>
            );
          })}

          <img
            src={fallbackSource.images[0].path}
            className={[
              "image",
              loaded ? "loaded" : "",
              loading ? "loading" : "",
              className,
            ].join(" ")}
            onLoad={handleImageLoaded}
            loading={loadingState === "eager" ? "eager" : "lazy"}
            alt={alt}
            width={fallbackSource.width}
            height={fallbackSource.height}
            {...props}
            style={{
              /*     backgroundImage: `url("${fallbackSource.placeholder}")`,
            backgroundRepeat: "no-repeat",
            backgroundSize: "100% 100%", */
              ...props.style,
            }}
          />
        </picture>
      </div>{" "}
      <style jsx>{`
        .aspectRatio {
          position: relative;
          height: 0;
        }

        .picture {
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
        }

        .image {
          width: 100%;
          height: 100%;
          display: block;
          opacity: 0;
          transition: opacity 200ms ease-out;
          object-fit: cover;
        }

        .image.loading {
          opacity: 0;
        }

        .image.loaded {
          opacity: 1;
        }
      `}</style>
    </>
  );
}

export default OptimizedImage;
